\section{Introduction}
\label{sec:intro}

The explosive growth of the internet provides us all with jobs.\footnotemark[1]
This is how you cite a paper~\cite{Walls:2011a}. Figure~\ref{fig:bar} shows how
good \sysname's whatever component is. 

Memory corruption is one of the oldest attacks in the context of software security. These attacks are much more common with the usage of low-level systems programming languages like c and c++. Throughout the history, there had been a number of defense mechanisms that had been used in order to protect from these memory corruption attacks. However, there had always been a tradeoff between the efficiency of the system after applying these defense mechanisms and the actual level of security that they provided. In order to happen a memory corruption attack there should be memory error at the first place in one of the two ways, i.e. Spatial error is an error that is normally defined as dereferencing an out of bounds pointer while dereferencing a dangling pointer is referred to as a temporal error. [cite here SoK]

When it comes to embedded systems the problem of memory corruption becomes much worsen because almost all of the defense mechanisms against memory corruption attacks doesn't make much sense in embedded environment due to additional constraints like hardware resources, loss of control and cost. As the existing defense mechanisms or building up new mechanisms don’t make much sense or less practical, what remains is to make embedded system robust to memory corruption attacks at the first place i.e. protect them from spatial and temporal errors so that systems are not exposed to memory corruption attacks. One possible way to get rid of the attacks is to use a memory safe language. However, as we are targeting the embedded space here, we have to make sure that this language would provide the necessary efficiency i.e. required runtime performance and the control i.e. the ability to control low-level hardware without any restrictions. 

Rust is a systems programming language that promises the memory safety while providing both efficiency and control at the same time. It follows a strong type system and a number of rules, which commonly referred to as ownership and borrowing features. It doesn't have runtime protection mechanisms like garbage collector that incurs much performance overheads. In contrary, most of the spatial and temporal errors are caught at the compilation time by the compiler, as it has the ability of recognizing the violations of the ownership and borrowing rules which as a result, protect you from the spatial and temporal errors at the first place. Unlike the spatial errors, most of the temporal errors are associated with dynamic memory and these errors are closely bounded and addressed by the ownership and borrowing rules of rust. Thus, the acceptability of rust for the systems that uses dynamic memory is comprehensible.
However, in the embedded space, use of dynamic memory is deficient and one would actually think whether it is worthy to use rust. Examining closely to the embedded systems, we can realize that there are other safety concerns that could be addressable with rust. First of all, regardless of the system involve dynamic memory or not, there could be always chance of programmer making spatial errors which could be addressed by rust. There could be other errors like null pointers, that would not involve the dynamic memory and according to the ownership rules of rust one could not declare the null pointers directly. It is clear that rust could address these errors directly in embedded systems. 

Apart from the spatial errors and other traditional errors that doesn't involve dynamic memory, concurrency bugs are one of the major security issues that are common in embedded space. Most of the modern embedded systems are driven by interrupts. With the interrupts there is a chance of our program ending up in a data race condition sooner or later. In order to have a race condition, there should be a global mutable variable that could be shared by both the Interrupt Service Routine (ISR) and the main thread of the program. However, there could be an exceptional case where both the ISR and main thread would try to access it at the same time causing the program to behave in undefined and unexpected manner. Since most of the embedded systems have real-time deadlines and operate in extreme critical conditions, there is no chance of even a single instance of undefined behavior within the program. Unfortunately, data races could be explained as a bug that is much harder to recognize even with rigorous amounts of testing [cite automatic Detection]. 

Embedded systems have a number of peripherals that let the system to interact with the external world. In embedded world, systems communicate with these peripherals using their memory mapped registers and thus, same kind of above-mentioned behavior could happen when the main thread and the interrupt handler try to access the global mutable memory mapped register which belong to a particular peripheral at the same time. We can’t make this memory immutable at the first place because peripheral should have a mutable memory mapped registers to support it’s working. Same type of principle prevents us from declaring global mutable variables as there are instances that we have to actually share the data. As an example operating system kernels depend heavily on callbacks and other event-driven programming mechanisms. Often, multiple components must both be able to mutate a shared data structure[case of writing an kernel in rust]
By default, using the global mutable variables are directly a violation of ownership model of rust where there should be only one owner to every object. The way that rust handle this situation is, it gives the extensibility to the user to define anything that violate its ownership model with a block of code marked as unsafe. So, particularly a developer trying to use global mutable variable, or a memory mapped register should use unsafe block whenever they are accessing or defining such variables and rust won't make any guarantees upon those sections as compiler couldn't make inferences within these areas. As a result, if you don’t take extreme care while you are writing these unsafe blocks, there's a chance of your embedded program would end up in a data race condition. 

Rust try to address this problem by a number of external libraries that are designed to handle concurrency in a safer manner. In reality, at the very end of these library there are unsafe blocks that are defined in an extreme careful manner so that you wouldn't ever end up in a data race condition as long as you are getting support through these libraries. But still, you should stick to these accepted libraries and if you want to implement a functionality that are not addressable by a library then you are on your own. One could also argue that it doesn't make much sense if these safety principles are not embed in to the rust language itself but given by the external libraries because it won’t make any difference between the two in that aspect. Apart from the concurrency support given by external libraries, other safety mechanisms that are provided by rust language itself. More importantly, if we look in to the future there’s always an increasing chance of embedded programs to use dynamic memory and with dynamic memory all the temporal errors could be easily addressable by rust. 

There had been a number of researches done in order to address the data race bugs in the embedded systems. Some of the researches directly focused upon defining a new language mechanism that would prevent from concurrency issues in embedded systems. In [cite medusa] the authors had defined a new high-level language based on actor model of concurrency. In [nesc Cite] authors have presented nesC, a systems programming language for networked embedded systems such as ‘motes’ i.e. sensors in a sensor network that could make compile time data race detection. In an another perspective, there had been researches that developed tools and frameworks to recognize the race conditions within the program developed within a language. In [cite sdRacer and racechecker] authors have proposed a framework/tools that could identify possible race conditions in embedded programs written in c language. 
 
Real Time Operating System (RTOS) is a piece of software with a set of APIs that developers can use to build applications. These systems provide primitive, low-level mechanisms for thread scheduling, synchronization, and communication[cite embedded RTOS].  They have methods to support the scheduling of tasks, to meet the hard deadlines that are common in embedded environment. With the use of a RTOS and proper scheduling mechanism in an embedded system, there’s always a chance of avoiding concurrency bugs such as data races. We try to find out the applicability of a Real Time Operating System in the context of embedded rust speculating that we could directly address the issues related to concurrency rather than sticking with lots of unsafe code  



\footnotetext[1]{Never start a paper with a pointless sentence describing the
popularity of computers or the internet.}

\Blindtext[3]

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{../figures/bar_chunk/bar_chunk_fraction.pdf}
%\vspace{-1.0cm}
\caption{\textbf{Short title.} Explain the figure and add a line about the main takeaway.}
\label{fig:bar}
\end{figure} 


